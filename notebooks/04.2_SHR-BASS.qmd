
title: "WildR Brain Tissue Spatial Transcriptomics Analysis"
editor: source
author: "Joe Boktor"
date: '2024-04-13'
format: 
  html:
    font-family: helvetica neue
    page-layout: full
    toc: true
    toc-location: left
    toc-depth: 5
    self-contained: true
    code-fold: false
    code-tools: true
    fig-align: center
    grid:
      sidebar-width: 200px
      body-width: 1100px
      margin-width: 200px
      gutter-width: 1.5em
---

# Background

Here we analyze

# Analysis Setup

Environment setup.

```{r, eval = FALSE}
#| warning: false

library(tidyverse)
library(magrittr)
library(glue)
library(Seurat)
library(grid)
library(biomaRt)
library(SingleR)
library(batchtools)
# stats 
library(lme4)
library(broom)
# parallelization
library(BiocParallel)
library(future)
library(furrr)
# plotting
library(RColorBrewer)
library(ggsci)
library(Matrix)
library(plotly)
library(DT)
library(gtsummary)
library(aplot)
library(patchwork)
library(viridis)

# setting paths
homedir <- "/central/groups/mthomson/jboktor"
wkdir <- glue("{homedir}/spatial_genomics/jess_2024-01-23")
source(glue("{wkdir}/notebooks/R_scripts/_misc_functions.R"))

# 12gb  limit (1500*1024^2 = 1572864000) * 8
options(future.globals.maxSize= 12582912000 * 2)
future::plan("multisession", workers = 8)

```


### Utility functions for BASS analysis

```{r, eval = FALSE}
run_BASS <- function(cnts, xys, n_celltype, n_domains, output_path) {
  require(BASS)
  require(Seurat)
  require(tidyverse)

  # Set up BASS object
  set.seed(42)
  BASS <- createBASSObject(cnts, xys, C = n_celltype, R = n_domains, beta_method = "fix")

  # Data pre-processing:
  # 1.Library size normalization followed with a log2 transformation
  # 2.Dimension reduction with PCA after standardizing all the genes
  # 3.Batch effect adjustment using the Harmony package
  BASS <- BASS.preprocess(
    BASS, 
    doLogNormalize = TRUE,
    doPCA = TRUE, 
    scaleFeature = TRUE, 
    nPC = 20
    )

  # Run BASS algorithm
  BASS <- BASS.run(BASS)

  # post-process posterior samples:
  # 1.Adjust for label switching with the ECR-1 algorithm
  # 2.Summarize the posterior samples to obtain the cell type labels, spatial 
  #   domain labels, and cell type proportion matrix estimate
  BASS <- BASS.postprocess(BASS, adjustLS = FALSE)
  saveRDS(BASS, output_path)

}

# utility functions for formating seurat list objects to BASS acceptable format
get_seurat_list_counts <- function(seur_list) {
  seur_list %>% purrr::map( ~ .@assays$SCT@counts %>% as.matrix()
  )
}
get_seurat_list_xys <- function(seur_list) {
  seur_list %>% purrr::map( ~ .@meta.data %>% 
  dplyr::select(center_x, center_y) %>%
  dplyr::rename(x = center_x, y = center_y)
  )
}
```

### Prepping data for BASS

```{r, eval = FALSE}
abca_color_pal <- readRDS(glue("{wkdir}/data/interim/abca_color_pal.rds"))
merged_rois <- readRDS(
    glue(
      "{wkdir}/data/interim/",
      "merged_roi_seurat_filtered_staNMF-updated_2024-07-24.rds"
    )
)
meta_df <- merged_rois@meta.data %>% glimpse()

```



Splitting seurat object into a list of samples, nest lists grouped by hemisphere and condition (SPF/WILDR)

```{r, eval = FALSE}
sid_list <- SplitObject(merged_rois, split.by = "slice_id")

saveRDS(
  sid_list,
  glue("{wkdir}/data/interim/merged_roi_seurat_filtered_staNMF-updated_sid_list_{Sys.Date()}.rds")
)

```


```{r, eval = FALSE}
sid_list <- readRDS(
  glue("{wkdir}/data/interim/merged_roi_seurat_filtered_staNMF-updated_sid_list_2024-08-20.rds")
)

sid_groups <- list(
  "SPF_right" = c("SPF run1 roi4", "SPF run2 roi2", "SPF run3 roi4", "SPF run4 roi4"),
  "SPF_left" = c("SPF run1 roi1", "SPF run2 roi3", "SPF run3 roi1", "SPF run4 roi1"),
  "WILDR_right" = c("WILDR run1 roi2", "WILDR run2 roi4", "WILDR run3 roi2", "WILDR run4 roi2"),
  "WILDR_left" = c("WILDR run1 roi3", "WILDR run2 roi1", "WILDR run3 roi3", "WILDR run4 roi3")
)

# genrating metdata to rank slices by bregma within conditions
sid_bregma <- meta_df %>% 
  dplyr::select(slice_id, bregma) %>%
  distinct() %>%
  glimpse()

sid_meta <- tidyr::unnest(
  tibble::enframe(sid_groups, name = "bass_group", value = "slice_id"),
  cols = c(slice_id)
  ) %>%
  left_join(sid_bregma, by = "slice_id") %>%
  arrange(bass_group, desc(bregma), rev(slice_id)) %>%
  glimpse()

# formating nested slice list
sid_nested_list <- list()
for (ii in seq_along(sid_meta$bass_group)) {
  bg  <- sid_meta$bass_group[ii]
  slice_id <- sid_meta$slice_id[ii]
  sid_nested_list[[bg]][[slice_id]] <- sid_list[[slice_id]]
}

```

Plotting subgrouped slices

```{r, eval = FALSE}
for (bg in names(sid_nested_list)) {
  patchplots <- list()
  for (sid in names(sid_nested_list[[bg]])) {
    patchplots[[sid]] <- sid_nested_list[[bg]][[sid]]@meta.data %>%
      ggplot(aes(x = center_x, y = center_y, color = singleR_labels)) +
      geom_point(size = 0.1) +
      scale_y_reverse() +
      coord_fixed() +
      guides(colour = guide_legend(override.aes = list(size=4))) +
      scale_color_manual(values = abca_color_pal[["class_colors"]]) +
      theme_bw()
  }
  patchplots[[bg]] <- patchplots[[1]] + patchplots[[2]] + patchplots[[3]] + patchplots[[4]] +
    plot_layout(guides = "collect", nrow = 1) +
    plot_annotation(title = bg)
  ggsave(
    glue("{wkdir}/figures/BASS/patchplots_{bg}_{Sys.Date()}.png"),
    patchplots[[bg]],
    width = 30, height = 12
  )
}

```

![SPF Right Hemi](../figures/BASS/patchplots_SPF_right_2024-08-20.png)
![SPF Left Hemi](../figures/BASS/patchplots_SPF_left_2024-08-20.png)
![WildR Right Hemi](../figures/BASS/patchplots_WILDR_right_2024-08-20.png)
![WildR Left Hemi](../figures/BASS/patchplots_WILDR_left_2024-08-20.png)


### Executing BASS 

Generating a batchtools parameter dataframe with contents for parallel runs

```{r, eval = FALSE}
bass_analysis_dir <- glue("{wkdir}/data/interim/BASS_results")
# dir.create(bass_analysis_dir, showWarnings = FALSE)
batchtools_params <- tibble()

# Loop over the different backgrounds
for (bg in names(sid_nested_list)) {
  # Get the list of matrices (counts) and list of dataframes (xys)
  cnts_list <- get_seurat_list_counts(sid_nested_list[[bg]])
  xys_list <- get_seurat_list_xys(sid_nested_list[[bg]])
  output_path = glue("{bass_analysis_dir}/{bg}_BASS_{Sys.Date()}.rds")
  
  # Create a single-row tibble for the current bg using as_tibble_row
  bg_row <- as_tibble_row(
    list(
      "cnts" = list(cnts_list),
      "xys" = list(xys_list),
      "n_celltype" = 23,
      "n_domains" = 11,
      "output_path" = output_path
    )
  )
  batchtools_params %<>% bind_rows(bg_row)
}

batchtools_params

```


Executing BASS analysis in parallel

```{r, eval = FALSE}
# configure registry ----
cluster_run <- glue("{get_time()}_BASS")
message("\n\nRUNNING:  ", cluster_run, "\n")
breg <- makeRegistry(
  file.dir = glue(
    "{wkdir}/.cluster_runs/",
    cluster_run
  ),
  seed = 42
)
breg$cluster.functions <- batchtools::makeClusterFunctionsSlurm(
  template = glue(
    "{wkdir}/batchtools_templates/",
    "batchtools.slurm_mamba-spatialomics.tmpl"
    ),
  scheduler.latency = 0.1,
  fs.latency = 1
)

# Submit Jobs ----
jobs <- batchMap(
  fun = run_BASS,
  args = batchtools_params,
  reg = breg
)
# jobs[, chunk := chunk(job.id, chunk.size = 1)]
# print(jobs[, .N, by = chunk])

submitJobs(jobs,
    resources = list(
        walltime = 1800, # min (10hrs)
        memory = "1000G",
        ncpus = 32,
        max.concurrent.jobs = 9999
    )
)

```


Visualizing results

Doesn't look very coherent, lots of variability between hemisphere x groups


```{r, eval = FALSE}

bass_res_paths <- list.files(
  glue("{wkdir}/data/interim/BASS_results"),
  full.names = TRUE,
  pattern = "2024-08-21.rds"
)

batchtools_params$bg <-  basename(batchtools_params$output_path) %>% 
  strex::str_before_nth("_", 2) %>% 
  gsub("_", " ", .)

names(bass_res_paths) <- basename(bass_res_paths) %>% 
  strex::str_before_nth("_", 2) %>% 
  gsub("_", " ", .)


for (grp in names(bass_res_paths)) {
  message(glue("Processing: {grp}"))
  
  grp_df <- batchtools_params %>% 
    filter(bg == grp) 

  xys_list <- grp_df$xys
  
  # remove a single list layer for xys and turn into a df
  xys_df <- xys_list[[1]] %>% 
  
    bind_rows(.id = "slice_id") %>% 
    glimpse()

  bs <- readRDS(
    bass_res_paths[[grp]]
  )

  clabels <- bs@results$c # cell type clusters
  zlabels <- bs@results$z # spatial domain labels
  pi_est <- bs@results$pi # cell type composition matrix

  zlabel_df <- data.frame("domain_labels" = unlist(zlabels))
  meta_df_bs <- xys_df %>% 
    bind_cols(zlabel_df) %>% 
    mutate(domain_labels = factor(domain_labels)) %>%
    glimpse()

  p_dom_cols <- ggplot(meta_df_bs, aes(x=x, y=y)) +
    geom_point(aes(color = domain_labels), size = 0.2) +
    theme_bw() +
    scale_color_d3(palette = "category20") +
    scale_y_reverse() +
    coord_fixed() +
    facet_wrap(~slice_id, ncol = 4)

  ggsave(
    glue("{wkdir}/figures/BASS/{grp}_domain-labels_{Sys.Date()}.png"),
    p_dom_cols,
    width = 30, height = 10
  )
}

```


![](../figures/BASS/WILDR right_domain-labels_2024-08-26.png){#fig-WR-RD}
![](../figures/BASS/WILDR left_domain-labels_2024-08-26.png){#fig-WR-LD}
![](../figures/BASS/SPF right_domain-labels_2024-08-26.png){#fig-SPF-RD}
![](../figures/BASS/SPF left_domain-labels_2024-08-26.png){#fig-SPF-LD}


```{r, eval = FALSE}

sid_groups_hemi <- list(
  "Right" = c("SPF run1 roi4", "SPF run2 roi2", "SPF run3 roi4", "SPF run4 roi4", 
    "WILDR run1 roi2", "WILDR run2 roi4", "WILDR run3 roi2", "WILDR run4 roi2"),
  "Left" = c("SPF run1 roi1", "SPF run2 roi3", "SPF run3 roi1", "SPF run4 roi1" ,
    "WILDR run1 roi3", "WILDR run2 roi1", "WILDR run3 roi3", "WILDR run4 roi3")
    )

# genrating metdata to rank slices by bregma within conditions
sid_bregma  %>% glimpse()

sid_meta_hemi <- tidyr::unnest(
  tibble::enframe(sid_groups_hemi, name = "bass_group", value = "slice_id"),
  cols = c(slice_id)
  ) %>%
  left_join(sid_bregma, by = "slice_id") %>%
  arrange(bass_group, desc(bregma), rev(slice_id)) %>%
  glimpse()

# formating nested slice list
sid_nested_list_hemi <- list()
for (ii in seq_along(sid_meta_hemi$bass_group)) {
  bg  <- sid_meta_hemi$bass_group[ii]
  slice_id <- sid_meta_hemi$slice_id[ii]
  sid_nested_list_hemi[[bg]][[slice_id]] <- sid_list[[slice_id]]
}

```

Plotting subgrouped slices

```{r, eval = FALSE}
for (bg in names(sid_nested_list_hemi)) {
  patchplots <- list()
  for (sid in names(sid_nested_list_hemi[[bg]])) {
    patchplots[[sid]] <- sid_nested_list_hemi[[bg]][[sid]]@meta.data %>%
      ggplot(aes(x = center_x, y = center_y, color = singleR_labels)) +
      geom_point(size = 0.1) +
      scale_y_reverse() +
      coord_fixed() +
      guides(colour = guide_legend(override.aes = list(size=4))) +
      scale_color_manual(values = abca_color_pal[["class_colors"]]) +
      theme_bw()
  }
  patchplots_combined <- wrap_plots(patchplots) +
    plot_layout(guides = "collect", nrow = 1) +
    plot_annotation(title = bg)
  ggsave(
    glue("{wkdir}/figures/BASS/patchplots_{bg}_{Sys.Date()}.png"),
    patchplots_combined,
    width = 35, height = 8
  )
}

```

![Right Hemi](../figures/BASS/patchplots_Right_2024-08-26.png)
![Left Hemi](../figures/BASS/patchplots_Left_2024-08-26.png)


### Executing BASS 

Generating a batchtools parameter dataframe with contents for parallel runs

```{r, eval = FALSE}
bass_analysis_dir <- glue("{wkdir}/data/interim/BASS_results")
# dir.create(bass_analysis_dir, showWarnings = FALSE)
batchtools_params <- tibble()

# Loop over the different backgrounds
for (bg in names(sid_nested_list_hemi)) {
  # Get the list of matrices (counts) and list of dataframes (xys)
  cnts_list <- get_seurat_list_counts(sid_nested_list_hemi[[bg]])
  xys_list <- get_seurat_list_xys(sid_nested_list_hemi[[bg]])
  output_path = glue("{bass_analysis_dir}/{bg}_BASS_{Sys.Date()}.rds")
  
  # Create a single-row tibble for the current bg using as_tibble_row
  bg_row <- as_tibble_row(
    list(
      "cnts" = list(cnts_list),
      "xys" = list(xys_list),
      "n_celltype" = 23,
      "n_domains" = 11,
      "output_path" = output_path
    )
  )
  batchtools_params %<>% bind_rows(bg_row)
}

batchtools_params

```


Executing BASS analysis in parallel

```{r, eval = FALSE}
# configure registry ----
cluster_run <- glue("{get_time()}_BASS")
message("\n\nRUNNING:  ", cluster_run, "\n")
breg <- makeRegistry(
  file.dir = glue(
    "{wkdir}/.cluster_runs/",
    cluster_run
  ),
  seed = 42
)
breg$cluster.functions <- batchtools::makeClusterFunctionsSlurm(
  template = glue(
    "{wkdir}/batchtools_templates/",
    "batchtools.slurm_mamba-spatialomics.tmpl"
    ),
  scheduler.latency = 0.1,
  fs.latency = 1
)

# Submit Jobs ----
jobs <- batchMap(
  fun = run_BASS,
  args = batchtools_params,
  reg = breg
)
# jobs[, chunk := chunk(job.id, chunk.size = 1)]
# print(jobs[, .N, by = chunk])

submitJobs(jobs,
    resources = list(
        walltime = 1800, # min (30hrs)
        memory = "300G",
        ncpus = 16,
        max.concurrent.jobs = 9999
    )
)

```




```{r, eval = FALSE}

bass_res_paths <- list.files(
  glue("{wkdir}/data/interim/BASS_results"),
  full.names = TRUE,
  pattern = "2024-08-26.rds"
)

batchtools_params$bg <-  basename(batchtools_params$output_path) %>% 
  strex::str_before_nth("_", 2) %>% 
  gsub("_", " ", .)

names(bass_res_paths) <- basename(bass_res_paths) %>% 
  strex::str_before_nth("_", 2) %>% 
  gsub("_", " ", .)


for (grp in names(bass_res_paths)) {
  message(glue("Processing: {grp}"))
  
  grp_df <- batchtools_params %>% 
    filter(bg == grp) 

  xys_list <- grp_df$xys
  
  # remove a single list layer for xys and turn into a df
  xys_df <- xys_list[[1]] %>% 
  
    bind_rows(.id = "slice_id") %>% 
    glimpse()

  bs <- readRDS(
    bass_res_paths[[grp]]
  )

  clabels <- bs@results$c # cell type clusters
  zlabels <- bs@results$z # spatial domain labels
  pi_est <- bs@results$pi # cell type composition matrix

  zlabel_df <- data.frame("domain_labels" = unlist(zlabels))
  meta_df_bs <- xys_df %>% 
    bind_cols(zlabel_df) %>% 
    mutate(domain_labels = factor(domain_labels)) %>%
    glimpse()

  p_dom_cols <- ggplot(meta_df_bs, aes(x=x, y=y)) +
    geom_point(aes(color = domain_labels), size = 0.2) +
    theme_bw() +
    scale_color_d3(palette = "category20") +
    scale_y_reverse() +
    coord_fixed() +
    facet_wrap(~slice_id, ncol = 4)

  ggsave(
    glue("{wkdir}/figures/BASS/{grp}_domain-labels_{Sys.Date()}.png"),
    p_dom_cols,
    width = 35, height = 10
  )
}

```



# Analysis attempt with CONCORDEX

```{r, eval = FALSE}
#______________________________________________________________________________
### CONCORDEX ANALYSIS
#______________________________________________________________________________

library(tidyverse)
library(magrittr)
library(glue)
library(Seurat)
library(grid)
library(future)
library(ggsci)
# library(furrr)

# library(scran)
library(concordexR)
library(bluster)
library(mbkmeans)
library(BiocParallel)

# devtools::install_github("drisso/mbkmeans")

# setting paths
homedir <- "/central/groups/mthomson/jboktor"
wkdir <- glue("{homedir}/spatial_genomics/jess_2024-01-23")
source(glue("{wkdir}/notebooks/R_scripts/_misc_functions.R"))
abca_color_pal <- readRDS(glue("{wkdir}/data/interim/abca_color_pal.rds"))
merged_rois <- readRDS(
    glue("{wkdir}/data/interim/","merged_roi_seurat_filtered_staNMF-updated_2024-07-24.rds")
)
meta_df <- merged_rois@meta.data %>% glimpse()



sample_meta_df <- meta_df %>% 
  filter(slice_id == "SPF run4 roi4") %>%
  glimpse()

coords <- dplyr::select(sample_meta_df, center_x, center_y) 
assignments <- sample_meta_df$singleR_labels


set.seed(42)
multicoreParam <- BiocParallel::MulticoreParam(workers = 8)
cdx_discrete <- calculateConcordex(
    x=coords,
    labels=assignments,
    BPPARAM = multicoreParam,
    BLUSPARAM=bluster::MbkmeansParam(
      12,
      batch_size = 50,
      max_iters = 5000
      )
    )
cdx_discrete %>% glimpse()

cdx_pred <- attr(cdx_discrete, "shrs")
pl_data <- dplyr::mutate(coords, shr=cdx_pred)

p <- ggplot(pl_data, aes(center_x, center_y, color=shr)) +
    geom_point(size=0.1) +
    scale_y_reverse() +
    coord_fixed() +
    guides(colour = guide_legend(override.aes = list(size=4))) +
    scale_color_d3(palette = "category20") +
    theme_bw()

ggsave(
  glue("{wkdir}/figures/SHR/concordex_{Sys.Date()}.png"),
  p,
  width = 6, height = 6
)


slices <- meta_df$slice_id %>% unique()
cdx_pred_list <- list()
pl_data_df <- data.frame()

for (slice in slices) {
  message("Calculating concordex for: ", slice)
  sample_meta_df <- meta_df %>% 
    filter(slice_id == slice)
  coords <- dplyr::select(sample_meta_df, center_x, center_y) 
  assignments <- sample_meta_df$singleR_labels

  set.seed(42)
  multicoreParam <- BiocParallel::MulticoreParam(workers = 8)
  cdx_discrete <- calculateConcordex(
      x=coords,
      labels=assignments,
      BPPARAM = multicoreParam,
      BLUSPARAM=bluster::MbkmeansParam(
        12,
        batch_size = 20,
        max_iters = 5000
        )
      )

  cdx_pred_list[[slice]] <- attr(cdx_discrete, "shrs")
  pl_data <- dplyr::mutate(coords, 
    shr = cdx_pred_list[[slice]],
    slice_id = slice
    )
  pl_data_df %<>% bind_rows(pl_data)
}

pl_data_df %>% glimpse()
meta_df %>% glimpse()

meta_df_jnd <- meta_df %>%
 left_join(pl_data_df, relationship = "many-to-many") %>%
  glimpse() 

p <- ggplot(meta_df_jnd, aes(center_x, center_y, color=shr)) +
    geom_point(size=0.1) +
    scale_y_reverse() +
    coord_fixed() +
    facet_wrap(~slice_id, ncol = 4) +
    guides(colour = guide_legend(override.aes = list(size=4))) +
    scale_color_d3(palette = "category20") +
    theme_bw()

ggsave(
  glue("{wkdir}/figures/SHR/concordex_all_{Sys.Date()}.png"),
  p,
  width = 20, height = 20
)
```

