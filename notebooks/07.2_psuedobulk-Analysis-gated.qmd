---
title: "WildR Brain Tissue Spatial Transcriptomics Analysis"
editor: source
author: "Joe Boktor"
date: '2024-04-13'
format: 
  html:
    font-family: helvetica neue
    page-layout: full
    toc: true
    toc-location: left
    toc-depth: 5
    self-contained: true
    code-fold: false
    code-tools: true
    fig-align: center
    grid:
      sidebar-width: 200px
      body-width: 1100px
      margin-width: 200px
      gutter-width: 1.5em
---

# Background

Here we analyze

# Analysis Setup

Environment setup.

```{r}
#| warning: false
library(tidyverse)
library(magrittr)
library(glue)
library(Seurat)
library(grid)
library(biomaRt)
library(SingleR)
library(batchtools)
library(strex)
# stats 
library(lme4)
library(broom)
# parallelization
library(BiocParallel)
library(future)
library(furrr)
# plotting
library(RColorBrewer)
library(ggsci)
library(Matrix)
library(plotly)
library(DT)
library(gtsummary)
library(aplot)
library(patchwork)
library(viridis)

# Load libraries
library(cowplot)
library(Matrix.utils)
library(edgeR)
library(Matrix)
library(reshape2)
library(S4Vectors)
library(SingleCellExperiment)
library(pheatmap)
library(apeglm)
library(png)
library(DESeq2)
library(RColorBrewer)
library(data.table)
library(DEGreport)

# setting paths
homedir <- "/central/groups/mthomson/jboktor"
wkdir <- glue("{homedir}/spatial_genomics/jess_2024-01-23")
source(glue("{wkdir}/notebooks/R_scripts/_misc_functions.R"))

# # 12gb  limit (1500*1024^2 = 1572864000) * 8
# options(future.globals.maxSize= 12582912000)
# future::plan("multisession", workers = 30)

```

Loading in data.

```{r, eval = FALSE}
abca_color_pal <- readRDS(glue("{wkdir}/data/interim/abca_color_pal.rds"))
merged_rois <- readRDS(
    glue(
      "{wkdir}/data/interim/",
      "merged_roi_seurat_filtered_staNMF-updated_2024-07-24.rds"
    )
)
meta_df <- merged_rois@meta.data %>% glimpse()

```

# Gating Cells
-- Tidygate scripts here:

## Compiling aggregated data

Loading in data and checking names
```{r, eval = FALSE}
annot_paths <- list.files(
  glue("{wkdir}/data/input/JAG_annotations_v2"),
  full.names = TRUE
)

annot_paths_r2 <- list.files(
  glue("{wkdir}/data/input/JAG_annotations_2024-10-15"),
  full.names = TRUE
)

annot_paths <- c(annot_paths, annot_paths_r2)

# Quality Check for file names
annot_types <- annot_paths %>% basename(.) %>% 
      str_before_last("_") %>% 
      str_after_first("_")

annot_types %>% table()

```


```{r, eval = FALSE}
#' Function to identify and rank gating attempt, helper func to select 
#' last gating attempt 

clean_gate_tries <- function(gate_list){
  unique_numbers <- gate_list %>%
    na.omit() %>% 
    unique() %>% 
    strsplit(",") %>%
    unlist() %>%
    as.numeric() %>%
    unique() %>%
    sort()
  }

gated_res_list <- annot_paths %>% 
  set_names(basename(.)) %>% 
  map(~ {
    annotation_type <- basename(.) %>% 
      str_before_last("_") %>% 
      str_after_first("_")
    
    df <- readRDS(.)
    clean_gates <- df$gated %>% clean_gate_tries()
    max_gate <- max(clean_gates, na.rm = TRUE)
    
    df %>%
      mutate(final_gate = grepl(max_gate, gated)) %>% 
      filter(final_gate) %>%
      mutate(!!sym(annotation_type) := TRUE)
  })

# Prepare the gated_res_list dataframes
gated_res_list_trim <- gated_res_list %>%
  map(~ .x %>% 
    select(starts_with("gated-")) %>% 
    mutate(cell_id = rownames(.))
  )

# compile a list of all cell ids for each gating type
agg_annots <- list()
for (ii in unique(annot_types)) {
  annot_type_paths <- names(gated_res_list_trim) %>% 
    keep(grepl(ii, .))
  agg_annots[[ii]] <- 
    gated_res_list_trim[annot_type_paths] %>% bind_rows()
}

# Join the gated results to meta_df
meta_df_updated <- meta_df %>%
  mutate(cell_id = rownames(.))

# now joining each aggregated list 
for (df in agg_annots) {
  meta_df_updated %<>% full_join(df)
}
meta_df_updated %>% glimpse()
meta_df_updated$slice_id %>% unique

meta_df_updated <- meta_df_updated %>% 
  mutate(gated_count = rowSums(select(., starts_with("gated-")), na.rm = TRUE)) %>%
  glimpse()

# counting the frequency of cell type labeling 
meta_df_updated$gated_count %>% table()

```

Visualizing Regional gates and determining cell overlap across multiple gates.

```{r, eval = FALSE}
p_gate_count <- meta_df_updated %>% 
  arrange(slice_id) %>% 
  mutate(gated_count = as.character(gated_count)) %>% 
  ggplot(aes(center_x, center_y)) +
  geom_point(aes(color = gated_count ), size = 0.3, alpha = 0.5) +
  theme_bw() +
  coord_fixed() +
  scale_y_reverse() +
  scale_color_manual(values = c("0" = "lightgray", "1" = "red", "2" = "green")) + # set custom colors
  facet_wrap(~slice_id, ncol = 4)

ggsave(
  filename = glue("{wkdir}/figures/gating/gated_count_scatter_{Sys.Date()}.png"),
  plot = p_gate_count,
  width = 20,
  height = 20
)

```

![Cell by gate scatterplot](../figures/gating/gated_count_scatter_2024-09-17.png)
Applying a strategy for selecting cell gate when in overlapping regions.

```{r, eval = FALSE}
meta_df_updated %>% glimpse()

# Strategy for prioritizing cells grouped in multiple gates
meta_df_gated <- meta_df_updated %>%
  mutate(across(starts_with("gated-"), 
    ~ ifelse(. == TRUE, cur_column(), NA))) %>%
  unite("temp_gate", all_of(unique(annot_types)), remove = FALSE, sep = ",", na.rm = TRUE) %>% 
  mutate(final_gate = case_when(
    is.na(temp_gate) | temp_gate == "" ~ "",
    grepl("gated-RT", temp_gate) ~ "RT",
    grepl("gated-Piriform", temp_gate) ~ "Piriform",
    grepl("gated-AMYG-BLA", temp_gate) ~ "AMYG_BLA",
    grepl("gated-AMYG-Cor_Tran", temp_gate) ~ "AMYG_CT",
    grepl("gated-AMYG-CeMe", temp_gate) ~ "AMYG_CeMe",
    grepl("gated-caudate", temp_gate) ~ "CAUD",
    grepl("gated-thalamus", temp_gate) ~ "THAL",
    grepl("gated-hippocampus", temp_gate) ~ "HIPP",
    grepl("gated-sscortex", temp_gate) ~ "SSC",
    grepl("gated-hyp", temp_gate) ~ "HYP",
    TRUE ~ "ERROR"
    )
  )

meta_df_gated$temp_gate %>% table()
meta_df_gated$final_gate %>% table()

# Visualizing manually identified regions
p_gate_ids <- meta_df_gated %>% 
  arrange(slice_id) %>% 
  ggplot(aes(center_x, center_y)) +
  geom_point(data = filter(meta_df_gated, final_gate == ""),
    size = 0.3, alpha = 0.5, color = "grey") +
  geom_point(data = filter(meta_df_gated, final_gate != ""),
    aes(color = final_gate ), size = 0.3, alpha = 0.5) +
  theme_bw() +
  coord_fixed() +
  scale_y_reverse() +
  scale_color_d3() +
  facet_wrap(~slice_id, ncol = 4) +
  guides(color = guide_legend(override.aes = list(size = 3)))

ggsave(
  filename = glue("{wkdir}/figures/gating/gated_labels_scatter_{Sys.Date()}.png"),
  plot = p_gate_ids,
  width = 20,
  height = 20
)

meta_df_gated %>% glimpse

# Saving results
saveRDS(
  meta_df_gated,
  glue(
    "{wkdir}/data/interim/",
    "gated-seurat-metadata_{Sys.Date()}.rds"
    )
  )

```


![Final additional cell labels](../figures/gating/gated_labels_scatter_2024-09-17.png)


# Prepping Pseudobulk Analysis

Joining gate metadata with Seurat Object

```{r, eval = FALSE}
meta_df_gated <- readRDS(
  glue(
    "{wkdir}/data/interim/",
    "gated-seurat-metadata_2024-12-31.rds"
    )
  )

# create a new column with cell types and gated regions
meta_df_gated %<>% 
  mutate(final_gate = case_when(
    final_gate != "" ~ glue(" {final_gate}"),
    TRUE ~ final_gate
  )) %>% 
  mutate(gated_cell_labels = glue("{singleR_labels}{final_gate}"))

meta_df_gated$gated_cell_labels %>% table()
meta_df_gated %>% glimpse()
```


# MOVE ME - Cell type proportions analysis within gated regions

```{r}
# Analysis to determine if there is enrichment in cell types within gated regions
nested_cell_abund <- meta_df_gated %>% 
  filter(final_gate != "") %>%
  group_by(slice_id, group, run, bregma, final_gate, singleR_labels) %>% 
  summarize(n = n(), .groups = "drop") %>%
  group_by(slice_id, final_gate) %>%
  mutate(rel_abundance = n / sum(n)) %>%
  ungroup() %>%
  group_by(final_gate, singleR_labels) %>% 
  nest()

gated_cell_type_prev_models_df <- nested_cell_abund %>% 
  mutate(count_model = purrr::map(data, possibly(function(df) lm(n ~ group + run + bregma, data = df), NULL))) %>% 
  mutate(rel_abund_model = purrr::map(data, possibly(function(df) lm(rel_abundance ~ group + run + bregma, data = df), NULL))) %>% 
  print(n = Inf)


# Extract model results for count models
count_model_results <- gated_cell_type_prev_models_df %>%
  filter(count_model != "NULL") %>%
  mutate(count_tidy = purrr::map(count_model, possibly(broom::tidy, NULL))) %>%
  select(final_gate, singleR_labels, count_tidy) %>%
  unnest(count_tidy) %>%
  mutate(model_type = "Cell Counts") %>% 
  glimpse()

# Extract model results for relative abundance models  
rel_abund_model_results <- gated_cell_type_prev_models_df %>%
  mutate(rel_abund_tidy = purrr::map(rel_abund_model, possibly(broom::tidy, NULL))) %>%
  select(final_gate, singleR_labels, rel_abund_tidy) %>%
  unnest(rel_abund_tidy) %>%
  mutate(model_type = "Relative Abundance") %>% 
  glimpse()

rel_abund_model_results %>% 
  filter(term == "groupwildr") %>% 
  View()

count_model_results %>% 
  filter(term == "groupwildr") %>% 
  View()

bothmods <- bind_rows(count_model_results, rel_abund_model_results)

# Combine results and create visualization
bothmods %>%
  mutate(colname = glue("{final_gate}_{singleR_labels}")) %>%
  mutate(signif = p.value <= 0.05) %>%
  # filter(term == "groupwildr") %>%
  ggplot(aes(
    x = estimate,
    y = fct_reorder(colname, estimate)
  )) +
  geom_bar(stat = "identity", width = 0.5, aes(fill = signif)) +
  geom_errorbar(aes(xmin = estimate - std.error, xmax = estimate + std.error),
                position = position_dodge(width = 0.8), width = 0.2) +
  theme_bw() +
  scale_fill_manual(values = c("TRUE" = "red", "FALSE" = "grey")) +
  labs(
    x = "Beta Coefficient WildR / SPF",
    y = NULL,
    fill = "Significant"
  ) +
  facet_grid(model_type ~ term, space = "free", scales = "free") +
  theme(legend.position = "top")

# bothmods$final_gate %>% unique()

# filter for only gates that have a add_difference(
sig_gates <- bothmods %>%
  mutate(colname = glue("{final_gate}_{singleR_labels}")) %>%
  mutate(signif = p.value <= 0.05) %>%
  filter(signif) %>%
  filter(term == "groupwildr") %>%
  filter(model_type == "Cell Counts") %>%
  group_by(final_gate) %>%
  summarize(n = n()) %>%
  pull(final_gate)

p_count_mod <- bothmods %>%
  mutate(colname = glue("{final_gate}_{singleR_labels}")) %>%
  mutate(signif = p.value <= 0.05) %>%
  filter(term == "groupwildr") %>%
  filter(model_type == "Cell Counts") %>%
  filter(final_gate %in% sig_gates) %>%
  ggplot(aes(
    x = estimate,
    y = fct_reorder(colname, estimate)
  )) +
  geom_bar(stat = "identity", width = 0.5, aes(fill = signif)) +
  theme_bw() +
  scale_fill_manual(values = c("TRUE" = "red", "FALSE" = "grey")) +
  labs(
    x = "Beta Coefficient WildR / SPF",
    y = NULL,
    fill = "Significant",
    title = "Cell Counts Models"
  ) +
  facet_grid(rows = vars(final_gate), space = "free", scales = "free") +
  theme(legend.position = "bottom",
        axis.text.y = element_text(size = 6),
        strip.text.y = element_text(angle = 0)) +
  scale_y_discrete(breaks = function(x) {
    # Only show labels for significant results
    sig_labels <- bothmods %>%
      filter(term == "groupwildr",
             model_type == "Cell Counts",
             p.value <= 0.05) %>%
      mutate(colname = glue("{final_gate}_{singleR_labels}")) %>%
      pull(colname)
    x[x %in% sig_labels]
  })

ggsave(
  glue("{wkdir}/figures/Celltype_prop_LM/",
    "celltype_counts_lm_results-counts-GATED_{Sys.Date()}.png"),
  p_count_mod,
  width = 4, height = 6
)

sig_gates_relab <- bothmods %>%
  mutate(colname = glue("{final_gate}_{singleR_labels}")) %>%
  mutate(signif = p.value <= 0.05) %>%
  filter(signif) %>%
  filter(term == "groupwildr") %>%
  filter(model_type == "Relative Abundance") %>%
  group_by(final_gate) %>%
  summarize(n = n()) %>%
  pull(final_gate)

p_relab_mod <- bothmods %>%
  mutate(colname = glue("{final_gate}_{singleR_labels}")) %>%
  mutate(signif = p.value <= 0.05) %>%
  filter(term == "groupwildr") %>%
  filter(model_type == "Relative Abundance") %>%
  filter(final_gate %in% sig_gates_relab) %>%
  ggplot(aes(
    x = estimate,
    y = fct_reorder(colname, estimate)
  )) +
  geom_bar(stat = "identity", width = 0.5, aes(fill = signif)) +
  # geom_errorbar(aes(xmin = estimate - std.error, xmax = estimate + std.error),
  #               position = position_dodge(width = 0.8), width = 0.2) +
  theme_bw() +
  scale_fill_manual(values = c("TRUE" = "red", "FALSE" = "grey")) +
  labs(
    x = "Beta Coefficient WildR / SPF",
    y = NULL,
    fill = "Significant",
    title = "Relative Abundance Models"
  ) +
  facet_grid(rows = vars(final_gate), space = "free", scales = "free") +
  theme(legend.position = "bottom",
        axis.text.y = element_text(size = 6),
        strip.text.y = element_text(angle = 0)) +
  scale_y_discrete(breaks = function(x) {
    # Only show labels for significant results
    sig_labels <- bothmods %>%
      filter(term == "groupwildr",
             model_type == "Relative Abundance",
             p.value <= 0.05) %>%
      mutate(colname = glue("{final_gate}_{singleR_labels}")) %>%
      pull(colname)
    x[x %in% sig_labels]
  })

ggsave(
  glue("{wkdir}/figures/Celltype_prop_LM/",
    "celltype_counts_lm_results-relab_GATED_{Sys.Date()}.png"),
  p_relab_mod,
  width = 4, height = 3.5
)

```



Adding metadata to seurat object

```{r, eval = FALSE}
meta_df_gated %>% glimpse()
meta_df %>% glimpse()

merged_rois$final_gate <- meta_df_gated$final_gate
merged_rois$gated_cell_labels <- meta_df_gated$gated_cell_labels
merged_rois@meta.data %>% glimpse

# Checking cell labels
merged_rois@meta.data$gated_cell_labels %>% table()
merged_rois@meta.data$singleR_labels %>% table()

# Get cell counts per label
label_counts <- table(merged_rois$gated_cell_labels)
# Get labels that have at least 200 cells
keep_labels <- names(label_counts[label_counts >= 200])
# Filter the Seurat object
merged_rois <- subset(merged_rois, gated_cell_labels %in% keep_labels)
merged_rois

```


Creating a single-cell experiment object.

```{r, eval = FALSE}
# Extract raw counts and metadata to create SingleCellExperiment object
counts <- merged_rois@assays$SCT@counts %>% glimpse()
metadata <- merged_rois@meta.data %>% glimpse()

# Set up metadata as desired for aggregation and DE analysis
metadata$cluster_id <- factor(merged_rois@meta.data$gated_cell_labels)

# Create single cell experiment object
sce <- SingleCellExperiment(
  assays = list(counts = counts),
  colData = metadata
)

# ## Check the counts matrix
# dim(counts(sce))
# counts(sce)[1:6, 1:6]
# dim(colData(sce))
# head(colData(sce))

cluster_names <- unique(colData(sce)$gated_cell_labels)
cluster_names
length(cluster_names)

# Extract unique names of samples (= levels of sample_id factor variable)
sample_names <- unique(colData(sce)$slice_id)
sample_names

# Total number of samples
length(sample_names)

# Subset metadata to include only the variables you want to aggregate across (here, we want to aggregate by sample and by cluster)
groups <- colData(sce)[, c("cluster_id", "slice_id")]
head(groups)

```

Aggregating across cluster-sample groups

```{r, eval = FALSE}
# transposing row/columns to have cell_ids as row names matching those of groups
aggr_counts <- aggregate.Matrix(
  t(counts(sce)), 
  groupings = groups, fun = "sum"
  ) %>% 
  t()

aggr_counts[1:6, 1:6]
dim(aggr_counts)

```

Creating a list of cell counts.

```{r, eval = FALSE}
## Initiate empty list
counts_ls <- list()

colnames(aggr_counts)
# tstrsplit(colnames(aggr_counts), "_")

for (i in 1:length(cluster_names)) {
  ## Extract indexes of columns in the global matrix that match a given cluster
  column_idx <- which(tstrsplit(colnames(aggr_counts), "_")[[1]] == cluster_names[i])

  ## Store corresponding sub-matrix as one element of a list
  counts_ls[[i]] <- aggr_counts[, column_idx]
  names(counts_ls)[i] <- cluster_names[i]
}

# Reminder: explore structure of metadata
head(colData(sce))

# Extract sample-level variables
metadata <- colData(sce) %>% 
  as.data.frame() %>% 
  dplyr::select(group, run, roi, bregma, slice_id) %>%
  distinct() %>%
  glimpse()
rownames(metadata) <- metadata$slice_id
head(metadata)

# Number of cells per sample and cluster
t <- table(colData(sce)$slice_id,
           colData(sce)$cluster_id)

t[1:6, 1:6]

```

Creating a metadata list.

```{r, eval = FALSE}
## Initiate empty list
metadata_ls <- list()

for (i in 1:length(counts_ls)) {
  
    ## Initiate a data frame for cluster i with one row per sample (matching column names in the counts matrix)
    df <- data.frame(cluster_sample_id = colnames(counts_ls[[i]]))
    
    ## Use tstrsplit() to separate cluster (cell type) and sample IDs
    df$cluster_id <- tstrsplit(df$cluster_sample_id, "_")[[1]]
    df$sample_id  <- tstrsplit(df$cluster_sample_id, "_")[[2]]
    
    
    ## Retrieve cell count information for this cluster from global cell count table
    idx <- which(colnames(t) == unique(df$cluster_id))
    cell_counts <- t[, idx]
    
    ## Remove samples with zero cell contributing to the cluster
    cell_counts <- cell_counts[cell_counts > 0]
    
    ## Match order of cell_counts and sample_ids
    sample_order <- match(df$sample_id, names(cell_counts))
    cell_counts <- cell_counts[sample_order]
    
    ## Append cell_counts to data frame
    df$cell_count <- cell_counts
    
    
    ## Join data frame (capturing metadata specific to cluster) to generic metadata
    df %<>% dplyr::left_join(metadata, by = c("sample_id" = "slice_id"))

    
    ## Update rownames of metadata to match colnames of count matrix, as needed later for DE
    rownames(df) <- df$cluster_sample_id
    
    ## Store complete metadata for cluster i in list
    metadata_ls[[i]] <- df
    names(metadata_ls)[i] <- unique(df$cluster_id)

}

# Explore the different components of the list
str(metadata_ls)

# Double-check that both lists have same names
all(names(counts_ls) == names(metadata_ls))

```

### DESEQ2 execution

Loop over each cell type, perform EDA, fit DESEQ2 model and save results

```{r, eval = FALSE}
for (clust in cluster_names){
  deseq2_dir <- glue("{wkdir}/figures/DESeq2/{Sys.Date()}/{clust}")
  dir.create(deseq2_dir, showWarnings = FALSE, recursive = TRUE)

  idx <- which(names(counts_ls) == clust)
  cluster_counts <- counts_ls[[idx]]
  cluster_metadata <- metadata_ls[[idx]]
  
  # Create DESeq2 object        
  dds <- DESeqDataSetFromMatrix(cluster_counts, 
                                colData = cluster_metadata, 
                                design = ~ group + run + bregma)

  # Transform counts for data visualization
  rld <- rlog(dds, blind=TRUE)
  
  # QC plots
  for (pca_group in c("group", "run", "cell_count")){
    p_pca <- DESeq2::plotPCA(rld, ntop = 500, intgroup = pca_group)
    ggsave(
      glue("{deseq2_dir}/PCA_{pca_group}_{Sys.Date()}.png"),
      p_pca,
      width = 7, height = 5
    )
  }
  
  # Extract the rlog matrix from the object and compute pairwise correlation values
  rld_mat <- assay(rld)
  rld_cor <- cor(rld_mat)
  
  png(glue("{deseq2_dir}/correlation_heatmap_{Sys.Date()}.png"),
  width = 800, height = 700)
  pheatmap(rld_cor, annotation = cluster_metadata[, c("group"), drop=F])
  dev.off()
  
  # RUNNING DESEQ2
  dds <- DESeq(dds)
  saveRDS(
    dds,
    glue("{deseq2_dir}/dds_{Sys.Date()}.rds")
  )

  # Plot dispersion estimates
  png(glue("{deseq2_dir}/dispersion_{Sys.Date()}.png"))
  p_disp <- plotDispEsts(dds)
  dev.off()

  # Check the coefficients for the comparison
  # resultsNames(dds)
  # Generate results object
  res <- results(dds, 
                name = "group_wildr_vs_spf",
                alpha = 0.05)
  # Shrink the log2 fold changes to be more appropriate using the apeglm method - should cite [paper]() when using this method
  res <- lfcShrink(dds, 
                  coef = "group_wildr_vs_spf",
                  res=res,
                  type = "apeglm")
  
  saveRDS(res, glue("{deseq2_dir}/res_{Sys.Date()}.rds"))
  
  padj_cutoff <- 0.05
  log2fc_cutoff <- 0.5

  res_tbl <- res %>%
    data.frame() %>%
    rownames_to_column(var = "gene") %>%
    as_tibble() %>%
    arrange(padj)

  # Subset the significant results
  sig_res <- dplyr::filter(res_tbl, padj < padj_cutoff) %>%
    dplyr::arrange(padj)


  # Volcano plot
  res_table_thres <- res_tbl[!is.na(res_tbl$padj), ] %>% 
    mutate(threshold = padj < padj_cutoff & abs(log2FoldChange) >= log2fc_cutoff)
  min(log10(res_table_thres$padj))

  ## Generate plot
  p_volcano <- ggplot(res_table_thres) +
    geom_point(aes(x = log2FoldChange, y = -log10(padj), colour = threshold)) +
    labs(x = "log2 fold change", y = "-log10 adjusted p-value") +
    # scale_y_continuous(limits = c(0, 250)) +
    scale_color_manual(values = c("grey60", "red3")) +
    theme_bw() +
    theme(legend.position = "none",
          plot.title = element_text(size = rel(1.3), hjust = 0.5),
          axis.title = element_text(size = rel(1.15)))

  ggsave(
    glue("{deseq2_dir}/volcano_plot_{Sys.Date()}.png"),
    p_volcano,
    width = 7, height = 5
  )

}

```

### Visualization

Plotting functions

```{r, eval = FALSE}
# Function to plot gene epxression on spatial data
plot_xy_gene_exp <- function(seur, gene) {
  gene = toupper(gene)
  meta_df <- merged_rois@meta.data
  meta_df <- bind_cols(meta_df, 
    genename = merged_rois@assays$SCT@data[gene, ]) %>% 
    # dplyr::mutate(slice_id = 
    #   glue("{toupper(group)} {run} {roi}")) %>%
    arrange(group, run, genename)
    
  p <- meta_df %>%
    ggplot(aes(x = center_x, y = center_y)) +
    geom_point(aes(color = genename), size = 0.3, alpha = 0.8) +
    facet_wrap(~slice_id, ncol = 4) +
    coord_fixed() +
    scale_y_reverse() +
    labs(color = gene) +
    scale_color_viridis_c(option = "viridis") +
    theme_bw()
  return(p)
}

# Function to plot gene epxression on spatial data
plot_celltype_xy_gene_exp <- function(seur, gene, cell_filter) {
  gene = toupper(gene)
  meta_df <- merged_rois@meta.data
  meta_df <- bind_cols(meta_df, 
    genename = merged_rois@assays$SCT@data[gene, ]) %>% 
  mutate(celltype_of_interest = ifelse(singleR_labels == cell_filter, TRUE, FALSE)) %>%
  arrange(group, run, genename)
      
  p <- meta_df %>%
    ggplot(aes(x = center_x, y = center_y)) +
    geom_point(data = dplyr::filter(meta_df, !celltype_of_interest),
        color = "lightgrey", size = 0.3, alpha = 0.5) +
    geom_point(data = dplyr::filter(meta_df, celltype_of_interest),
        aes(color = genename), size = 0.3, alpha = 0.8) +
    facet_wrap(~slice_id, ncol = 4) +
    coord_fixed() +
    scale_y_reverse() +
    labs(color = gene, title = glue("Plotting {gene} in {coi}")) +
    scale_color_viridis_c(option = "viridis") +
    theme_bw()
  return(p)
}

```

Loop through all results and aggregate data.

```{r, eval = FALSE}

padj_cutoff <- 0.1
log2fc_cutoff <- 0.2
deseq2_results_dir <- glue("{wkdir}/figures/DESeq2/2024-08-22")

deg_paths <- list.files(
  deseq2_results_dir,
  full.names = TRUE,
  recursive = TRUE,
  pattern = "res_*"
  )

deg_all_df <- deg_paths %>%
  purrr::set_names(
    strex::str_after_nth(., "/", -2) %>% strex::str_before_last("/")
    ) %>%
  purrr::map(
    ~ readRDS(.x) %>%
      data.frame() %>%
      rownames_to_column(var = "gene") %>%
      as_tibble()
  ) %>%
  bind_rows(.id = "cell_type") %>%
  mutate(threshold = padj < padj_cutoff & abs(log2FoldChange) >= log2fc_cutoff) %>%
    glimpse()

hits_df <- deg_all_df %>%
  filter(threshold)

saveRDS(
  hits_df,
  glue("{wkdir}/data/interim/pseudobulk/deseq2_threshold_hits.rds")
)
#   View

```

```{r}
hits_df <- readRDS(
  glue("{wkdir}/data/interim/pseudobulk/deseq2_threshold_hits.rds")
)

hits_df %>% DT::datatable()

```

Plotting spatial gene expression of DEGs.

```{r, eval = FALSE}

plot_deg_df <- deg_all_df %>%
  filter(threshold) 

for (ii in 1:nrow(plot_deg_df)){
  gid <- plot_deg_df$gene[ii]
  coi <- plot_deg_df$cell_type[ii]
  
  message(glue("Plotting: {gid} - {coi}"))
  figout_all <- glue("{wkdir}/figures/gene_exp_scatter/2024-08-23/{gid}_expression_SCT_2024-08-23.png")
  figout_celltype <- glue("{wkdir}/figures/gene_exp_scatter/2024-08-23/{gid}_{coi}_expression_SCT_2024-08-23.png")
  
  if (!file.exists(figout_all)) {
    p <- plot_xy_gene_exp(merged_rois, gid)
    ggsave(filename = figout_all, p,
      width = 16, height = 16
    )
  }

  if (!file.exists(figout_celltype)) {
    p2 <- plot_celltype_xy_gene_exp(merged_rois, gid, coi)
    ggsave(filename = figout_celltype, p2,
      width = 16, height = 16
    )
  }
}

```

# Plotting boxplots of pseudo bulk data

```{r, eval = FALSE}

format_psudobulk_df <- function(gene_id, cluster_name){
  idx <- which(names(counts_ls) == cluster_name)
  cluster_metadata <- metadata_ls[[idx]]
  cluster_counts <- counts_ls[[idx]]
  
  cluster_counts_df <- as.data.frame(cluster_counts) %>%
    rownames_to_column(var = "gene") %>%
    filter(gene == gene_id) %>%
    tidyr::gather(cluster_sample_id, count, -gene) %>%
    left_join(cluster_metadata, by = "cluster_sample_id")
  
  return(cluster_counts_df)
}


for (ii in 1:nrow(plot_deg_df)){
  message(glue("Plotting: {plot_deg_df$gene[ii]} - {plot_deg_df$cell_type[ii]}"))
  
  psb_df <- format_psudobulk_df(
    plot_deg_df$gene[ii], 
    plot_deg_df$cell_type[ii]
    )
  p_box <- ggplot(psb_df, aes(x = group, y = count)) +
    geom_boxplot(outlier.alpha = 0) +
    geom_point(aes(color = cell_count), size = 2, position = position_jitter(width = 0.3)) +
    theme_bw() +
    scale_color_viridis(option = "magma") +
    labs(x = NULL, y = "Total Sample Gene Counts", 
      color = "Cell count", title = glue("{plot_deg_df$gene[ii]} - {plot_deg_df$cell_type[ii]}"))
  ggsave(
    glue("{wkdir}/figures/pseudobulk_boxplots/{Sys.Date()}/{plot_deg_df$gene[ii]}_{plot_deg_df$cell_type[ii]}_boxplot.png"),
    p_box,
    width = 4, height = 4
  )
}

```


# GO Analysis

```{r, eval = FALSE}
library(clusterProfiler)
library(org.Mm.eg.db)

gene_symbols <- hits_df$gene %>% unique()
gene_symbol_map <- data.frame(
  gene_symbol = gene_symbols,
  gene_symbol_formatted = tools::toTitleCase(tolower(gene_symbols))
)

deg_df <- hits_df %>%
  left_join(gene_symbol_map, by = c("gene" = "gene_symbol")) %>%
  mutate(direction = if_else(
    log2FoldChange > 0, "WildR Upregulated", "WildR Downregulated"
  ))

# format params for GO enrichment
go_params <- expand.grid(
  c("BP", "CC", "MF"),
  c( "WildR Upregulated", "WildR Downregulated")
) %>% 
dplyr::rename(
  Ontology = Var1,
  direction = Var2
)

future::plan("multisession", workers = 16)

enrichGO_res <-
  furrr::future_pmap(
    list(
      go_params$Ontology,
      go_params$direction
    ),
    ~ enrichGO(
      gene = deg_df %>% filter(direction == ..2) %>% 
        pull(gene_symbol_formatted),
      OrgDb = org.Mm.eg.db,
      keyType = "SYMBOL",
      ont = ..1,
      pAdjustMethod = "BH",
      pvalueCutoff = 0.05,
      qvalueCutoff = 0.1,
      readable = TRUE
    ) %>%
      as.data.frame() %>%
      mutate(Ontology = ..1, direction = ..2)
  ) %>%
  bind_rows() %>% 
  glimpse()


saveRDS(
  enrichGO_res,
  glue(
    "{wkdir}/data/interim/pseudobulk",
    "enrichGO_res_{Sys.Date()}.rds"
  )
)

```


Visualizing GO results

```{r, eval = FALSE}
# Visualizing results
enrichGO_res <- readRDS(
  glue(
    "{wkdir}/data/interim/pseudobulk",
    "enrichGO_res_{Sys.Date()}.rds"
  )
)

for (direc in unique(enrichGO_res$direction)) {
  for (ont in unique(enrichGO_res$Ontology)) {
    
    message(glue("Plotting: {ont} - {direc}"))
    
    p <- enrichGO_res %>%
      filter(Count >= 2) %>%
      filter(direction == direc) %>%
      filter(Ontology == ont) %>%
      filter(qvalue <= 0.05) %>%
      slice_min(qvalue, n = 30, with_ties = FALSE) %>%
      mutate(Description = glue("{Description}:{Ontology}:\n{geneID}")) %>% 
      ggplot(aes(x = -log10(p.adjust), y = fct_reorder(Description, -p.adjust))) +
      geom_col(width = 0.4, fill = "red") +
      theme_bw() +
      labs(
        x = "-log10(adj. P-value)", y = NULL,
        title = glue("{ont}: {direc}")
      )

    ggsave(
      glue(
        "{wkdir}/figures/pseudobulk_GO/",
        "GO_enrichment_{ont}_{direc}_{Sys.Date()}.png"
        ),
      p,
      width = 8, height = 9
    )
  }
}

```

# Results

In our analysis, we examined 23 cell types and performed differential expression analysis. Counts were then processed and normalized using SCTransform on the spatial assay. After creating a SingleCellExperiment object from the SCT counts preprocessed data, we aggregated the counts across cluster-sample groups and prepared the metadata accordingly. Using DESeq2, we fitted models to each cell type's aggregated count data, adjusting for group, run, and bregma.

$gene \sim group + run + bregma$



### 1. **Hypothalamic GABAergic Neurons (HY GABA)**

-   **Altered Neurotransmitter Release and Synaptic Function**
    -   **Genes Involved:**
        -   **GRIN2A**: This gene, related to NMDA receptor subunits, plays a key role in synaptic plasticity and neurotransmitter release in GABAergic neurons. Its downregulation could affect inhibitory signaling, impacting overall brain excitability and potentially leading to altered stress response or circadian rhythms.
        -   **STX1A**: Involved in the release of neurotransmitters, particularly GABA, from synaptic vesicles, impacting the inhibitory tone in the hypothalamus.
        -   **SLC1A3**: Though primarily associated with glutamate transport, changes in this gene within GABAergic neurons could indirectly impact the balance between excitation and inhibition.
    -   **Physiological Impact:**
        -   Alterations in these genes may lead to changes in inhibitory control within the hypothalamus, potentially affecting stress response, feeding behavior, and circadian rhythms.
    -   **Citations:**
        -   Sudhof, T. C., & Rothman, J. E. (2009). Membrane fusion: grappling with SNARE and SM proteins. *Science*, *323*(5913), 474-477.
        -   Traynelis, S. F., et al. (2010). Glutamate receptor ion channels: structure, regulation, and function. *Pharmacological Reviews*, *62*(3), 405–496.
-   **Ion Channel Function and Neuronal Excitability**
    -   **Genes Involved:**
        -   **SCN4B**: Beta subunit of sodium channels, crucial for action potential propagation in GABAergic neurons. Alterations could disrupt firing patterns, impacting the hypothalamic regulation of physiological processes like thermoregulation.
        -   **KCNA3**: Affects potassium channels, which are vital for setting the resting membrane potential and neuronal excitability. In GABAergic neurons, this impacts inhibitory signaling, which is critical for maintaining hypothalamic functions.
        -   **KCNS3**: Modulates potassium channels in GABAergic neurons, influencing neuronal excitability and potentially affecting hypothalamic control of energy homeostasis and circadian rhythms.
    -   **Physiological Impact:**
        -   Disruptions in these channels may lead to altered hypothalamic function, impacting energy balance, thermoregulation, and overall neuronal excitability.
    -   **Citations:**
        -   Hille, B. (2001). Ion Channels of Excitable Membranes. *Sinauer Associates*.
        -   Catterall, W. A., & Swanson, T. M. (2015). Structural basis for pharmacology of voltage-gated sodium and calcium channels. *Molecular Pharmacology*, *88*(1), 141-150.
-   **Inflammatory and Immune Response**
    -   **Genes Involved:**
        -   **C1QA**: Involved in the complement system, which may indicate a role in neuroinflammation within the hypothalamic GABAergic neurons. Neuroinflammation in this area could lead to alterations in stress responses and metabolic regulation.
        -   **P2RY12**: Associated with microglial activation, potentially influencing hypothalamic responses to systemic inflammation.
    -   **Physiological Impact:**
        -   This could lead to altered neuroinflammatory states in the hypothalamus, impacting behaviors such as stress reactivity and feeding.
    -   **Citations:**
        -   Hickman, S., Izzy, S., et al. (2018). Microglia in neurodegeneration. *Nature Neuroscience*, *21*(10), 1359–1369.
        -   Kettenmann, H., et al. (2011). Physiology of microglia. *Physiological Reviews*, *91*(2), 461-553.

### 2. **Anterior Hypothalamic Glutamatergic Neurons (HYa Glut)**

-   **Neuronal Differentiation and Development**
    -   **Genes Involved:**
        -   **PAX6**: A critical transcription factor involved in the development of glutamatergic neurons. Alterations here could impact the development and differentiation of neurons in the anterior hypothalamus, which plays a role in behavior regulation, including stress and aggression.
    -   **Physiological Impact:**
        -   Disruption of PAX6 may result in abnormal development of hypothalamic circuits, potentially affecting stress responses and social behaviors.
    -   **Citations:**
        -   Ashery-Padan, R., & Gruss, P. (2001). Pax6 lights-up the way for eye development. *Current Opinion in Cell Biology*, *13*(6), 706-714.
-   **Metabolic Regulation**
    -   **Genes Involved:**
        -   **ZEB2**: This transcription factor plays a role in the differentiation of neural cells and could be involved in hypothalamic regulation of energy balance and metabolism.
        -   **CRHBP**: Involved in the regulation of corticotropin-releasing hormone, impacting the stress axis and energy balance.
    -   **Physiological Impact:**
        -   Changes in these genes could affect the hypothalamic control of metabolic processes, influencing energy expenditure and appetite regulation.
    -   **Citations:**
        -   Zhang, Y., et al. (2005). ZEB1 and ZEB2: multifunctional repressors of the TGF-β signaling pathway. *Cell Cycle*, *4*(6), 712-716.
        -   Kiss, A., et al. (1996). Corticotropin-releasing hormone-binding protein: localization, regulation, and function in the brain. *Molecular Neurobiology*, *12*(1), 1-22.

### 3. **Cerebral Nuclei GABAergic Neurons (CNU-LGE GABA)**

-   **Synaptic Transmission and Neurotransmitter Release**
    -   **Genes Involved:**
        -   **CRHBP**: This gene plays a role in modulating the release of corticotropin-releasing hormone, which influences stress response circuits within the cerebral nuclei.
    -   **Physiological Impact:**
        -   Alterations here could affect the function of stress-related circuits within the cerebral nuclei, potentially leading to anxiety-related behaviors.
    -   **Citations:**
        -   Kiss, A., et al. (1996). Corticotropin-releasing hormone-binding protein: localization, regulation, and function in the brain. *Molecular Neurobiology*, *12*(1), 1-22.
-   **Neuroinflammation and Microglial Function**
    -   **Genes Involved:**
        -   **P2RY12**: As a microglial marker, changes in this gene within GABAergic neurons of the cerebral nuclei suggest alterations in neuroimmune interactions, potentially influencing neuroinflammatory states.
    -   **Physiological Impact:**
        -   Could lead to increased susceptibility to neurodegeneration or dysregulated immune responses within the cerebral nuclei.
    -   **Citations:**
        -   Hickman, S., et al. (2018). Microglia in neurodegeneration. *Nature Neuroscience*, *21*(10), 1359–1369.

This refined interpretation highlights the importance of considering cell type and regional specificity when linking gene expression changes to potential physiological outcomes in the brain. Each gene's function is assessed within the context of the particular neuronal population affected, leading to more targeted hypotheses about potential behavioral and physiological changes.

```{r}
sessionInfo()
```